# Story 3.4: Production Deployment & Monitoring Setup

## Status
Draft

## Story
**As a** DevOps engineer,
**I want** production environment deployed with monitoring and alerting configured,
**so that** we can detect and respond to issues during the workshop.

## Acceptance Criteria

1. Production environment deployed to DigitalOcean with separate Supabase production instance (isolated from staging)
2. Environment variables configured for production: Supabase production credentials, CORS settings (if frontend/backend on different subdomains), file size limits, processing timeouts
3. DigitalOcean monitoring dashboards configured tracking: CPU/memory usage per service, request rate, error rate (4xx, 5xx), response time p95
4. Log aggregation enabled: application logs from frontend and backend centralized in DigitalOcean logs with retention policy (7 days minimum)
5. Health check alerts configured: notify if health endpoints fail 3 consecutive times, alert if error rate exceeds 10% over 5-minute window
6. Backup strategy documented: database backup schedule (daily), storage bucket backup (manual pre-workshop snapshot), rollback procedure
7. Production smoke test passes: upload → process → download workflow for each file type succeeds in production environment

## Tasks / Subtasks

- [ ] Set up production DigitalOcean environment (AC: 1)
  - [ ] Create DigitalOcean App Platform production apps (frontend and backend)
  - [ ] Configure separate production Supabase instance
  - [ ] Set up production domains and SSL certificates
  - [ ] Configure production networking and security settings
  - [ ] Set up production resource allocation and scaling
  - [ ] Verify isolation from staging environment

- [ ] Configure production environment variables (AC: 2)
  - [ ] Set up Supabase production credentials in DigitalOcean
  - [ ] Configure CORS settings for production domains
  - [ ] Set production file size limits (10MB default, 50MB if using Coolify)
  - [ ] Configure processing timeouts for production workloads
  - [ ] Set up production-specific API endpoints and URLs
  - [ ] Validate all environment variables are properly configured

- [ ] Implement DigitalOcean monitoring dashboards (AC: 3)
  - [ ] Create CPU usage monitoring for frontend and backend services
  - [ ] Set up memory usage tracking with alerts
  - [ ] Configure request rate monitoring by endpoint
  - [ ] Set up error rate tracking (4xx, 5xx) with alerting
  - [ ] Implement response time p95 monitoring
  - [ ] Create custom dashboards for workshop-specific metrics

- [ ] Configure centralized log aggregation (AC: 4)
  - [ ] Set up DigitalOcean log aggregation for frontend logs
  - [ ] Configure backend log collection and forwarding
  - [ ] Implement log parsing and structured logging
  - [ ] Set up log retention policy (7 days minimum)
  - [ ] Create log search and filtering capabilities
  - [ ] Test log aggregation with sample log entries

- [ ] Implement health check and alerting system (AC: 5)
  - [ ] Configure health endpoint monitoring for frontend and backend
  - [ ] Set up alert for 3 consecutive health check failures
  - [ ] Configure error rate alerting (>10% over 5 minutes)
  - [ ] Set up alerting channels (email, Slack, etc.)
  - [ ] Create escalation procedures for critical alerts
  - [ ] Test alerting system with simulated failures

- [ ] Document and implement backup strategy (AC: 6)
  - [ ] Configure daily automated database backups
  - [ ] Set up manual pre-workshop storage bucket snapshots
  - [ ] Document backup retention and recovery procedures
  - [ ] Create rollback procedure for production deployments
  - [ ] Test backup and restore procedures
  - [ ] Document backup access and security procedures

- [ ] Execute production smoke testing (AC: 7)
  - [ ] Create comprehensive smoke test suite
  - [ ] Test upload → process → download workflow for PDF files
  - [ ] Test upload → process → download workflow for DOCX files
  - [ ] Test upload → process → download workflow for PPTX files
  - [ ] Test upload → process → download workflow for XLSX files
  - [ ] Validate all processing options (Fast/Quality, OCR)
  - [ ] Verify error handling and user feedback in production

- [ ] Create production deployment documentation (AC: All)
  - [ ] Document production deployment procedures
  - [ ] Create monitoring and alerting runbook
  - [ ] Document backup and recovery procedures
  - [ ] Create troubleshooting guide for common issues
  - [ ] Document security and access procedures
  - [ ] Create emergency contact and escalation procedures

- [ ] Set up production security measures (AC: All)
  - [ ] Configure production firewall rules
  - [ ] Set up SSL/TLS certificates for all services
  - [ ] Implement rate limiting for API endpoints
  - [ ] Configure security headers and CSP
  - [ ] Set up production access controls and authentication
  - [ ] Test security measures with penetration testing

## Dev Notes

### Previous Story Insights
[Source: Story 3.3 - Load Testing & Performance Optimization]
- Performance benchmarks established for production targets
- Auto-scaling configurations validated for production load
- Monitoring requirements identified for production observability

[Source: Story 1.7 - Deployment]
- Initial deployment infrastructure established
- DigitalOcean App Platform configuration documented
- Supabase integration patterns implemented

### Production Deployment Architecture
[Source: docs/architecture.md#Deployment-Architecture]

**Production Environment Structure:**
```
Production Environment (DigitalOcean)
├── Frontend App (Next.js)
│   ├── Domain: workshop-docs.example.com
│   ├── SSL: Automatic
│   ├── Scaling: Auto (1-5 instances)
│   └── Monitoring: CPU, Memory, Requests
├── Backend App (FastAPI)
│   ├── Domain: api.workshop-docs.example.com
│   ├── SSL: Automatic
│   ├── Scaling: Auto (1-10 instances)
│   └── Monitoring: CPU, Memory, Requests
└── Supabase Production
    ├── Database: PostgreSQL
    ├── Storage: File buckets
    ├── Auth: Production keys
    └── Backups: Daily + Manual
```

**Environment Configuration:**
```yaml
# Production environment variables
frontend:
  NEXT_PUBLIC_SUPABASE_URL: "https://prod-project.supabase.co"
  NEXT_PUBLIC_SUPABASE_ANON_KEY: "prod-anon-key"
  NEXT_PUBLIC_API_URL: "https://api.workshop-docs.example.com"
  NODE_ENV: "production"

backend:
  SUPABASE_URL: "https://prod-project.supabase.co"
  SUPABASE_KEY: "prod-service-key"
  DEBUG: "false"
  MAX_FILE_SIZE: "10485760"  # 10MB
  PROCESSING_TIMEOUT: "300"
  LOG_LEVEL: "INFO"
```

### DigitalOcean Monitoring Configuration
[Source: docs/deployment/digitalocean-config-updates.md]

**Monitoring Dashboard Setup:**
```yaml
# Frontend monitoring
frontend_metrics:
  - cpu_usage_percentage
  - memory_usage_percentage
  - request_rate_per_minute
  - response_time_p95
  - error_rate_percentage
  - active_connections

# Backend monitoring
backend_metrics:
  - cpu_usage_percentage
  - memory_usage_percentage
  - request_rate_per_minute
  - response_time_p95
  - error_rate_percentage
  - active_processing_jobs
  - database_connection_pool
```

**Alert Configuration:**
```yaml
alerts:
  health_check_failure:
    condition: "health_endpoint_status != 200"
    consecutive_failures: 3
    severity: "critical"
    channels: ["email", "slack"]
  
  high_error_rate:
    condition: "error_rate_percentage > 10"
    duration: "5m"
    severity: "warning"
    channels: ["email"]
  
  high_response_time:
    condition: "response_time_p95 > 5000ms"
    duration: "2m"
    severity: "warning"
    channels: ["email"]
```

### Log Aggregation Strategy
[Source: docs/architecture.md#Logging]

**Structured Logging Format:**
```python
# Backend structured logging
import structlog

logger = structlog.get_logger()

def log_request(request_id, method, endpoint, status_code, duration):
    logger.info(
        "api_request",
        request_id=request_id,
        method=method,
        endpoint=endpoint,
        status_code=status_code,
        duration_ms=duration,
        timestamp=datetime.utcnow().isoformat()
    )

def log_processing_start(document_id, file_type, file_size):
    logger.info(
        "processing_started",
        document_id=document_id,
        file_type=file_type,
        file_size_bytes=file_size,
        timestamp=datetime.utcnow().isoformat()
    )
```

**Frontend Logging:**
```typescript
// Frontend structured logging
interface LogEntry {
  level: 'info' | 'warn' | 'error';
  component: string;
  action: string;
  userId?: string;
  sessionId: string;
  timestamp: string;
  metadata?: Record<string, any>;
}

const logEvent = (entry: LogEntry) => {
  // Send to centralized logging service
  fetch('/api/logs', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(entry)
  });
};
```

### Backup and Recovery Strategy
[Source: docs/deployment/supabase-setup.md]

**Database Backup Configuration:**
```sql
-- Automated daily backups
ALTER SYSTEM SET backup_schedule = '0 2 * * *';  -- Daily at 2 AM

-- Point-in-time recovery enabled
ALTER SYSTEM SET wal_level = 'replica';
ALTER SYSTEM SET archive_mode = 'on';
ALTER SYSTEM SET archive_command = 'cp %p /backup/%f';
```

**Storage Backup Procedure:**
```bash
#!/bin/bash
# Manual pre-workshop backup script
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="workshop_backup_${TIMESTAMP}"

# Create storage bucket backup
supabase storage backup \
  --bucket "documents" \
  --output "/backups/${BACKUP_NAME}.tar.gz"

# Verify backup integrity
tar -tzf "/backups/${BACKUP_NAME}.tar.gz" | head -10
```

### Health Check Implementation
[Source: docs/architecture.md#Health-Checks]

**Health Check Endpoints:**
```python
# Backend health check
@app.get("/api/health")
async def health_check():
    try:
        # Check database connection
        await db.execute("SELECT 1")
        
        # Check Supabase storage
        storage_client.list_buckets()
        
        # Check Docling availability
        docling_version = get_docling_version()
        
        return {
            "status": "healthy",
            "timestamp": datetime.utcnow().isoformat(),
            "version": app.version,
            "dependencies": {
                "database": "healthy",
                "storage": "healthy",
                "docling": docling_version
            }
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "timestamp": datetime.utcnow().isoformat(),
            "error": str(e)
        }, 503
```

**Frontend Health Check:**
```typescript
// Frontend health check component
const HealthCheck = () => {
  const [health, setHealth] = useState<'healthy' | 'unhealthy'>('healthy');
  
  useEffect(() => {
    const checkHealth = async () => {
      try {
        const response = await fetch('/api/health');
        const data = await response.json();
        setHealth(data.status === 'healthy' ? 'healthy' : 'unhealthy');
      } catch (error) {
        setHealth('unhealthy');
      }
    };
    
    const interval = setInterval(checkHealth, 30000); // Check every 30 seconds
    checkHealth(); // Initial check
    
    return () => clearInterval(interval);
  }, []);
  
  return health === 'healthy' ? 
    <div className="text-green-600">System Healthy</div> : 
    <div className="text-red-600">System Unhealthy</div>;
};
```

### File Locations
[Source: docs/architecture/source-tree.md]

**Production Configuration Files:**
- `.digitalocean/production.yaml` - DigitalOcean production configuration
- `backend/app/core/production_config.py` - Production-specific configuration
- `frontend/next.config.production.js` - Production Next.js configuration
- `docs/deployment/production-runbook.md` - Production deployment procedures

**Monitoring and Logging Files:**
- `backend/app/utils/structured_logger.py` - Structured logging utilities
- `frontend/src/utils/production-logger.ts` - Frontend logging utilities
- `scripts/production/backup.sh` - Backup automation scripts
- `scripts/production/health-check.sh` - Health check automation

**Documentation Files:**
- `docs/deployment/production-deployment-guide.md` - Deployment procedures
- `docs/deployment/production-monitoring-guide.md` - Monitoring setup
- `docs/deployment/production-backup-procedures.md` - Backup and recovery
- `docs/deployment/production-troubleshooting.md` - Troubleshooting guide

### Integration with Existing Components
[Source: Current component implementations]

**Production Configuration Integration:**
```python
# Enhanced configuration management
class ProductionConfig:
    def __init__(self):
        self.supabase_url = os.getenv("SUPABASE_URL")
        self.supabase_key = os.getenv("SUPABASE_KEY")
        self.max_file_size = int(os.getenv("MAX_FILE_SIZE", "10485760"))
        self.processing_timeout = int(os.getenv("PROCESSING_TIMEOUT", "300"))
        self.log_level = os.getenv("LOG_LEVEL", "INFO")
        
    def validate(self):
        """Validate all required production variables"""
        required_vars = ["SUPABASE_URL", "SUPABASE_KEY"]
        for var in required_vars:
            if not getattr(self, var.lower()):
                raise ValueError(f"Missing required environment variable: {var}")
```

### Testing Requirements
[Source: docs/architecture/coding-standards.md#Testing-Standards]

**Production Testing Requirements:**
- Smoke tests for all critical workflows
- Health check endpoint validation
- Performance testing in production environment
- Security testing and validation
- Backup and recovery testing

**Specific Testing Requirements:**
- End-to-end workflow testing for all file types
- Error handling validation in production
- Monitoring and alerting system testing
- Load testing with production-like traffic
- Security penetration testing

### Security Considerations
[Source: docs/architecture.md#Security-Standards]

**Production Security Measures:**
- HTTPS enforcement for all endpoints
- API rate limiting and throttling
- Input validation and sanitization
- Secure environment variable management
- Regular security updates and patches
- Access control and authentication

**Security Monitoring:**
- Failed login attempt tracking
- Unusual access pattern detection
- Security event logging and alerting
- Regular security audits
- Vulnerability scanning and assessment

## Testing

### Test Standards
[Source: docs/architecture/coding-standards.md#Testing-Standards]

**Production Testing Framework:**
- Use production-like environment for testing
- Test all critical workflows end-to-end
- Validate monitoring and alerting systems
- Test backup and recovery procedures
- Security testing and validation

**Test Coverage Requirements:**
- All API endpoints in production environment
- Database connectivity and performance
- File upload and download workflows
- Error handling and user feedback
- Monitoring and alerting functionality
- Backup and recovery procedures

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-06 | 1.0 | Initial story draft for production deployment and monitoring setup | Scrum Master |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

No debugging issues encountered during story creation.

### Completion Notes

Story 3.4 created with comprehensive production deployment and monitoring requirements. The story covers all aspects of production deployment including environment setup, monitoring configuration, log aggregation, health checks, backup strategy, and smoke testing. All acceptance criteria from Epic 3 have been addressed with detailed implementation guidance.

### File List

**Story File:**
- `docs/stories/3.4.production-deployment-monitoring-setup.md` (created)

**Planned Implementation Files:**
- `.digitalocean/production.yaml` (to be created)
- `backend/app/core/production_config.py` (to be created)
- `backend/app/utils/structured_logger.py` (to be created)
- `scripts/production/backup.sh` (to be created)
- `docs/deployment/production-runbook.md` (to be created)

## QA Results

### Review Date: 2025-10-06

### Reviewed By: Scrum Master

### Review Summary

Story 3.4 provides comprehensive requirements for production deployment and monitoring setup. The story addresses all critical production aspects including environment configuration, monitoring dashboards, log aggregation, health checks, backup strategy, and smoke testing.

### Strengths

1. **Comprehensive Production Setup**: Complete production environment configuration
2. **Robust Monitoring**: Detailed monitoring and alerting configuration
3. **Backup Strategy**: Thorough backup and recovery procedures
4. **Security Focus**: Production security measures and monitoring
5. **Smoke Testing**: Comprehensive production validation procedures

### Areas of Consideration

1. **Production Costs**: DigitalOcean production costs need to be budgeted
2. **Environment Isolation**: Need to ensure complete separation from staging
3. **Monitoring Overhead**: Alert fatigue prevention strategies needed

### Recommendations

1. **Staggered Deployment**: Deploy backend first, then frontend
2. **Monitoring Baseline**: Establish performance baselines before workshop
3. **Backup Testing**: Test backup and recovery procedures regularly

### Test Coverage Assessment

- ✅ Production environment setup
- ✅ Environment variable configuration
- ✅ Monitoring dashboard setup
- ✅ Log aggregation configuration
- ✅ Health check and alerting
- ✅ Backup strategy implementation
- ✅ Production smoke testing

### Production Readiness

The story addresses all critical production deployment requirements with comprehensive monitoring and backup strategies. The detailed approach ensures reliable production operation during the workshop with proper observability and recovery procedures.

### Gate Status

Gate: DRAFT → Ready for development review