# Story 2.2: Enhanced Status Display & Progress Indicators

## Status
Draft

## Story
**As a** workshop attendee,
**I want** clear visual feedback showing processing progress and estimated time,
**so that** I understand what's happening and how long to wait.

## Acceptance Criteria

1. Processing screen displays animated progress indicator (spinner or progress bar) with current status text: "Uploading file...", "Queued for processing...", "Processing document...", "Finalizing..."
2. Status updates polled every 2 seconds from backend with visual state transitions (no jarring UI jumps)
3. Estimated time remaining displayed based on processing mode: Fast mode ("~30 seconds"), Quality mode with OCR ("~2 minutes"), adjusts if processing exceeds estimates
4. Backend `/api/status/{document_id}` returns enriched response: status, progress_stage (uploading/queued/processing/finalizing), elapsed_time, filename
5. Visual differentiation between stages: uploading (blue pulse), processing (amber spinner), complete (green checkmark), failed (red error icon)
6. Processing screen remains responsive on mobile devices with appropriately sized progress indicators
7. Status polling stops automatically when status reaches 'complete' or 'failed' terminal states

## Tasks / Subtasks

- [ ] Create useStatusPolling hook for real-time status updates (AC: 2, 7)
  - [ ] Create `frontend/src/hooks/useStatusPolling.ts`
  - [ ] Implement polling logic with 2-second intervals
  - [ ] Add automatic polling stop for terminal states
  - [ ] Handle polling errors and retry logic
  - [ ] Export status, progress, and control functions

- [ ] Enhance ProcessingCard component with animated progress indicators (AC: 1, 5)
  - [ ] Update `frontend/src/components/ProcessingCard.tsx`
  - [ ] Add animated spinner for processing state
  - [ ] Add progress bar with percentage display
  - [ ] Implement visual differentiation between stages
  - [ ] Add smooth transitions between status changes
  - [ ] Ensure mobile-responsive sizing

- [ ] Implement estimated time calculation and display (AC: 3)
  - [ ] Add time estimation logic based on processing options
  - [ ] Calculate remaining time: Fast (~30s), Quality+OCR (~2min)
  - [ ] Adjust estimates if processing exceeds initial estimates
  - [ ] Display formatted time remaining in UI
  - [ ] Handle edge cases (very long processing, etc.)

- [ ] Enhance backend status endpoint with progress stages (AC: 4)
  - [ ] Update `backend/app/api/endpoints/status.py`
  - [ ] Add progress_stage field to response model
  - [ ] Implement stage mapping: uploading/queued/processing/finalizing
  - [ ] Add elapsed_time calculation
  - [ ] Update DocumentStatusResponse schema
  - [ ] Add proper error handling for status queries

- [ ] Create status polling integration component (AC: 2, 7)
  - [ ] Create `frontend/src/components/StatusPoller.tsx`
  - [ ] Integrate useStatusPolling hook with ProcessingCard
  - [ ] Handle polling lifecycle (start/stop/cleanup)
  - [ ] Add loading states during status transitions
  - [ ] Implement proper cleanup on component unmount

- [ ] Add mobile-responsive progress indicators (AC: 6)
  - [ ] Ensure progress indicators scale properly on mobile
  - [ ] Test touch-friendly sizing (minimum 44px targets)
  - [ ] Optimize spinner animations for mobile performance
  - [ ] Verify text readability on small screens
  - [ ] Test across different mobile devices

- [ ] Create frontend status polling tests (AC: 2, 7)
  - [ ] Create `frontend/src/tests/hooks/useStatusPolling.test.ts`
  - [ ] Test polling interval timing
  - [ ] Test automatic polling stop on terminal states
  - [ ] Test error handling and retry logic
  - [ ] Test cleanup on component unmount

- [ ] Create ProcessingCard component tests (AC: 1, 5, 6)
  - [ ] Update `frontend/src/tests/components/ProcessingCard.test.tsx`
  - [ ] Test animated progress indicators
  - [ ] Test visual differentiation between stages
  - [ ] Test mobile responsiveness
  - [ ] Test time estimation display

- [ ] Create backend status endpoint tests (AC: 4)
  - [ ] Update `backend/tests/test_api/test_status.py`
  - [ ] Test enriched status response format
  - [ ] Test progress_stage mapping
  - [ ] Test elapsed_time calculation
  - [ ] Test error handling for invalid document IDs

- [ ] Create integration tests for status polling workflow (AC: All)
  - [ ] Create `backend/tests/test_integration/test_status_polling.py`
  - [ ] Test end-to-end status polling flow
  - [ ] Test status transitions through all stages
  - [ ] Test time estimation accuracy
  - [ ] Test polling behavior under various conditions

- [ ] Update processing page integration (AC: All)
  - [ ] Update `frontend/src/app/processing/[id]/page.tsx`
  - [ ] Integrate StatusPoller component
  - [ ] Pass processing options for time estimation
  - [ ] Handle navigation between states
  - [ ] Test complete workflow from upload to completion

- [ ] Add accessibility features for progress indicators (AC: 1, 6)
  - [ ] Add ARIA live regions for status updates
  - [ ] Add screen reader announcements for progress
  - [ ] Ensure keyboard navigation for progress controls
  - [ ] Add proper color contrast for status indicators
  - [ ] Test with screen readers

## Dev Notes

### Previous Story Insights
[Source: Story 2.1 - Processing Options UI & Backend Integration]
- ProcessingOptions component already implemented with OCR and mode selection
- Backend processing_service.py already handles different processing modes
- Processing time estimates established: Fast (~30s), Quality (~2min)
- ProcessingCard component exists but needs enhancement for real-time progress
- Status endpoint exists but needs enrichment with progress stages

[Source: Story 1.5 - Docling Processing Pipeline]
- Background task processing is implemented
- Document status tracking works through processing pipeline
- Processing stages: queued → processing → complete/failed
- Error handling and logging infrastructure in place

### Status Display Architecture
[Source: docs/architecture.md#Frontend-Architecture]

**Frontend State Management:**
```typescript
interface StatusState {
  status: 'uploading' | 'queued' | 'processing' | 'finalizing' | 'complete' | 'failed';
  progress: number; // 0-100
  progress_stage: string;
  elapsed_time: number; // seconds
  estimated_time_remaining: number; // seconds
  filename: string;
  processing_options: ProcessingOptions;
}

// Hook interface
interface UseStatusPollingReturn {
  status: StatusState;
  isPolling: boolean;
  error: string | null;
  startPolling: (documentId: string) => void;
  stopPolling: () => void;
}
```

**Backend Status Response Model:**
```python
# Enhanced DocumentStatusResponse
class DocumentStatusResponse(BaseModel):
    id: str
    filename: str
    status: str
    processing_options: Dict[str, Any]
    created_at: str
    completed_at: Optional[str]
    error_message: Optional[str]
    progress_stage: str  # New: uploading/queued/processing/finalizing
    elapsed_time: Optional[int]  # New: seconds since creation
    progress: int  # New: 0-100 percentage
    estimated_time_remaining: Optional[int]  # New: seconds
```

### Progress Indicator Specifications
[Source: docs/architecture/tech-stack.md#Frontend-Technology-Stack]

**Animation Requirements:**
- Use CSS animations for smooth transitions
- Spinner animation: 1s rotation loop
- Progress bar: smooth width transitions
- Status changes: fade transitions (300ms)
- Mobile-optimized: reduced motion support

**Visual Design:**
- Uploading: Blue pulse animation (#3b82f6)
- Processing: Amber spinner (#f59e0b)
- Complete: Green checkmark (#10b981)
- Failed: Red error icon (#ef4444)
- Progress bar: Gradient fill based on status

### Status Polling Implementation
[Source: docs/architecture.md#API-Specification]

**Polling Strategy:**
```typescript
// useStatusPolling hook implementation
const useStatusPolling = () => {
  const [isPolling, setIsPolling] = useState(false);
  const [status, setStatus] = useState<StatusState | null>(null);
  
  const startPolling = useCallback(async (documentId: string) => {
    setIsPolling(true);
    
    const poll = async () => {
      try {
        const response = await fetch(`/api/status/${documentId}`);
        const data = await response.json();
        
        setStatus(data);
        
        // Stop polling for terminal states
        if (data.status === 'complete' || data.status === 'failed') {
          setIsPolling(false);
          return;
        }
      } catch (error) {
        console.error('Status polling error:', error);
      }
      
      // Continue polling if still active
      if (isPolling) {
        setTimeout(poll, 2000); // 2-second interval
      }
    };
    
    poll(); // Initial call
  }, [isPolling]);
  
  return { status, isPolling, startPolling, stopPolling };
};
```

### Time Estimation Logic
[Source: docs/architecture.md#Performance-Standards]

**Processing Time Estimates:**
- Fast mode without OCR: ~30 seconds
- Fast mode with OCR: ~60 seconds
- Quality mode without OCR: ~90 seconds
- Quality mode with OCR: ~120 seconds

**Dynamic Estimation:**
```typescript
const calculateEstimatedTime = (
  processingOptions: ProcessingOptions,
  elapsedTime: number
): number => {
  const baseTime = processingOptions.mode === 'fast' ? 30 : 90;
  const ocrMultiplier = processingOptions.ocr_enabled ? 2 : 1;
  const estimatedTotal = baseTime * ocrMultiplier;
  
  // Adjust if exceeding estimate
  if (elapsedTime > estimatedTotal) {
    return Math.min(estimatedTotal * 1.5, 300); // Cap at 5 minutes
  }
  
  return Math.max(estimatedTotal - elapsedTime, 5); // Minimum 5 seconds
};
```

### Backend Status Enhancement
[Source: docs/architecture.md#Backend-Architecture]

**Progress Stage Mapping:**
```python
def _get_progress_stage(status: str, elapsed_time: int = None) -> str:
    """Get detailed progress stage from status and elapsed time."""
    stages = {
        'queued': 'Queued for processing',
        'processing': 'Converting document',
        'complete': 'Processing complete',
        'failed': 'Processing failed'
    }
    
    # Add uploading stage for very recent documents
    if status == 'queued' and (elapsed_time or 0) < 5:
        return 'Uploading file...'
    
    # Add finalizing stage for long-running processing
    if status == 'processing' and (elapsed_time or 0) > 100:
        return 'Finalizing...'
    
    return stages.get(status, 'Unknown')

def _calculate_progress(status: str, elapsed_time: int = None, 
                       processing_options: dict = None) -> int:
    """Calculate progress percentage based on status and elapsed time."""
    if status == 'complete':
        return 100
    elif status == 'failed':
        return 0
    elif status == 'queued':
        return min(elapsed_time or 0, 10)  # 0-10% for queued
    elif status == 'processing':
        # Estimate based on processing mode and elapsed time
        base_time = 30 if processing_options.get('mode') == 'fast' else 90
        ocr_multiplier = 2 if processing_options.get('ocr_enabled') else 0
        estimated_total = base_time + (base_time * ocr_multiplier)
        
        progress = 10 + min((elapsed_time or 0) / estimated_total * 80, 80)
        return min(progress, 95)  # Cap at 95% until complete
    return 0
```

### Mobile Responsive Design
[Source: docs/architecture/source-tree.md#Frontend-Directory-Structure]

**Mobile Optimization:**
```typescript
// Responsive progress indicator sizing
const progressStyles = {
  spinner: {
    base: "w-8 h-8", // 32px - meets 44px minimum with padding
    sm: "w-6 h-6",   // 24px for very small screens
    lg: "w-12 h-12"  // 48px for larger screens
  },
  progressBar: {
    base: "h-2",     // 8px height - touch friendly
    sm: "h-1",       // 4px for compact display
    lg: "h-3"        // 12px for easier interaction
  }
};

// Mobile-first responsive classes
<div className="w-full max-w-sm sm:max-w-md md:max-w-lg">
  <Progress className="h-2 sm:h-3" value={progress} />
</div>
```

### Testing Strategy
[Source: docs/architecture/coding-standards.md#Testing-Standards]

**Frontend Tests:**
```typescript
describe('useStatusPolling', () => {
  it('should poll every 2 seconds', async () => {
    const { result } = renderHook(() => useStatusPolling());
    
    act(() => {
      result.current.startPolling('test-id');
    });
    
    // Verify polling calls
    await waitFor(() => {
      expect(fetch).toHaveBeenCalledTimes(3); // Initial + 2 polls
    }, { timeout: 5000 });
  });
  
  it('should stop polling on complete status', async () => {
    // Test automatic polling stop
  });
});
```

**Backend Tests:**
```python
def test_status_enhanced_response():
    """Test enhanced status response with progress stages."""
    response = client.get("/api/status/test-doc-id")
    assert response.status_code == 200
    
    data = response.json()
    assert "progress_stage" in data
    assert "elapsed_time" in data
    assert "progress" in data
    assert data["progress_stage"] in ["Uploading file...", "Queued for processing", 
                                     "Converting document", "Finalizing...", 
                                     "Processing complete", "Processing failed"]
```

### File Locations
[Source: docs/architecture/source-tree.md]

**Frontend Files:**
- `frontend/src/hooks/useStatusPolling.ts` - New hook for status polling
- `frontend/src/components/StatusPoller.tsx` - New component for polling integration
- `frontend/src/components/ProcessingCard.tsx` - Enhanced with progress indicators
- `frontend/src/app/processing/[id]/page.tsx` - Updated with status polling
- `frontend/src/tests/hooks/useStatusPolling.test.ts` - New hook tests
- `frontend/src/tests/components/ProcessingCard.test.tsx` - Updated component tests

**Backend Files:**
- `backend/app/api/endpoints/status.py` - Enhanced with progress stages
- `backend/app/models/schemas.py` - Updated DocumentStatusResponse model
- `backend/tests/test_api/test_status.py` - Updated endpoint tests
- `backend/tests/test_integration/test_status_polling.py` - New integration tests

### Integration with Existing Components
[Source: Current ProcessingCard Implementation]

**ProcessingCard Enhancement:**
```typescript
// Enhanced ProcessingCard with real-time progress
const ProcessingCard = ({ documentId }: { documentId: string }) => {
  const { status, isPolling, error } = useStatusPolling();
  
  useEffect(() => {
    if (documentId) {
      startPolling(documentId);
    }
    
    return () => stopPolling();
  }, [documentId]);
  
  return (
    <Card>
      {/* Animated status icon */}
      <div className="relative">
        {getStatusIcon(status?.status)}
        {isPolling && (
          <div className="absolute inset-0 animate-ping">
            {getStatusIcon(status?.status)}
          </div>
        )}
      </div>
      
      {/* Progress bar with animation */}
      <Progress 
        value={status?.progress || 0} 
        className="transition-all duration-300"
      />
      
      {/* Time estimation */}
      {status?.estimated_time_remaining && (
        <div className="text-sm text-muted-foreground">
          ~{formatTime(status.estimated_time_remaining)} remaining
        </div>
      )}
    </Card>
  );
};
```

### Error Handling
[Source: docs/architecture.md#Error-Handling]

**Polling Error Handling:**
```typescript
const useStatusPolling = () => {
  const [error, setError] = useState<string | null>(null);
  const retryCount = useRef(0);
  
  const pollWithRetry = async (documentId: string, attempt: number = 0) => {
    try {
      const response = await fetch(`/api/status/${documentId}`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setStatus(data);
      setError(null);
      retryCount.current = 0; // Reset retry count on success
      
    } catch (err) {
      console.error('Status polling error:', err);
      
      if (attempt < 3) {
        // Exponential backoff: 2s, 4s, 8s
        const delay = 2000 * Math.pow(2, attempt);
        setTimeout(() => pollWithRetry(documentId, attempt + 1), delay);
      } else {
        setError('Unable to get status updates. Please refresh the page.');
        setIsPolling(false);
      }
    }
  };
};
```

### Performance Considerations
[Source: docs/architecture.md#Performance-Standards]

**Polling Optimization:**
- 2-second intervals balance responsiveness with server load
- Automatic cleanup prevents memory leaks
- Exponential backoff reduces server pressure during errors
- Request cancellation on component unmount
- Efficient state updates prevent unnecessary re-renders

**Mobile Performance:**
- Reduced motion support for accessibility
- Optimized animations using CSS transforms
- Lightweight polling payload (< 1KB)
- Efficient progress calculations

### Accessibility Requirements
[Source: docs/architecture.md#Security-and-Performance]

**ARIA Implementation:**
```typescript
<div
  role="status"
  aria-live="polite"
  aria-label={`Document processing: ${status?.progress_stage}`}
>
  <Progress
    value={status?.progress || 0}
    aria-label={`Processing progress: ${status?.progress}% complete`}
  />
  <span className="sr-only">
    {status?.progress_stage}. {status?.progress}% complete.
    {status?.estimated_time_remaining && 
      ` Estimated time remaining: ${formatTime(status.estimated_time_remaining)}`}
  </span>
</div>
```

### Success Criteria Validation

**Story Complete When:**
1. ✅ Animated progress indicators display with current status text
2. ✅ Status polling every 2 seconds with smooth transitions
3. ✅ Time estimation based on processing mode with dynamic adjustment
4. ✅ Backend returns enriched status response with progress stages
5. ✅ Visual differentiation between processing stages
6. ✅ Mobile-responsive progress indicators
7. ✅ Automatic polling stop for terminal states
8. ✅ Comprehensive test coverage for all scenarios
9. ✅ Accessibility features implemented
10. ✅ Error handling and retry logic working

## Testing

### Testing Standards
[Source: docs/architecture/coding-standards.md#Testing-Standards]

**Frontend Testing Requirements:**
- Test file location: `frontend/src/tests/`
- Use Vitest + React Testing Library
- Test user behavior, not implementation details
- Mock external dependencies (fetch API)
- Test accessibility features with screen reader mocks
- Mobile responsiveness testing with viewport emulation

**Backend Testing Requirements:**
- Test file location: `backend/tests/`
- Use pytest with async support
- Test both success and error scenarios
- Mock Supabase client for isolation
- Test API response format and timing
- Integration tests for complete workflows

**Specific Testing Requirements:**
- Polling interval timing accuracy
- Progress calculation edge cases
- Time estimation accuracy across processing modes
- Mobile responsiveness across device sizes
- Accessibility compliance (WCAG AA)
- Error handling and retry behavior
- Memory leak prevention (cleanup)
- Performance under load (30 concurrent users)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-05 | 1.0 | Initial story draft for enhanced status display and progress indicators | Scrum Master |

## Dev Agent Record

### Agent Model Used

[To be populated by development agent]

### Debug Log References

[To be populated by development agent]

### Completion Notes

[To be populated by development agent]

### File List

[To be populated by development agent]

## QA Results

[To be populated by QA agent after implementation]